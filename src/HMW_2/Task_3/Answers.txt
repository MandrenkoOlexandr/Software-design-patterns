Чому цей код порушує принципи SOLID?

A. Liskov Substitution Principle (LSP) — Принцип підстановки Лісков
У класі Bicycle метод drive() кидає помилку throw new IllegalStateException(...).
Якщо у вас є список List<Vehicle> і ви захочете викликати drive() для всіх елементів, програма "впаде", коли дійде до
велосипеда. Велосипед не може замінити абстрактний Vehicle у цьому контексті, бо він ламає очікувану поведінку
(замість їзди — помилка).

B. Interface Segregation Principle (ISP) — Принцип розділення інтерфейсу
Батьківський клас Vehicle нав'язує метод drive() всім нащадкам. Але велосипед не "драйвить" (drive — це зазвичай про
мотор), він "їздить верхи" (ride). Клас Bicycle змушений реалізовувати (або глушити помилкою) метод drive(),
який йому не потрібен і логічно чужий. Інтерфейс (контракт) класу Vehicle занадто "жирний".



Як це виправити?
Ми повинні розділити поняття "Транспортний засіб" (як сутність з назвою та брендом) і "Спосіб пересування"
(інтерфейси поведінки).

План змін:
Залишити Vehicle тільки для спільних даних (ім'я, бренд, швидкість).
Прибрати метод drive() з Vehicle.
Створити інтерфейси для різних типів руху: Drivable (для авто) та Rideable (для велосипедів).
Реалізувати відповідні інтерфейси в класах.